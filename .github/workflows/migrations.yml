# GitHub Actions workflow for database migration CI/CD
name: Database Migration CI/CD

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'src/db/migrations/**'
      - 'src/db/migration_manager.py'
      - 'scripts/migrate.py'
      - 'docker/Dockerfile.migrations'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'src/db/migrations/**'
      - 'src/db/migration_manager.py'
      - 'scripts/migrate.py'
      - 'docker/Dockerfile.migrations'

env:
  POSTGRES_DB: test_orchestrator
  POSTGRES_USER: test_user
  POSTGRES_PASSWORD: test_password

jobs:
  validate-migrations:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_DB: ${{ env.POSTGRES_DB }}
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install uv
      run: pip install uv
    
    - name: Install dependencies
      run: uv sync --frozen
    
    - name: Validate migration file naming
      run: |
        # Check that all migration files follow V{version}__{description}.sql pattern
        for file in src/db/migrations/*.sql; do
          if [[ ! $(basename "$file") =~ ^V[0-9]+__.*\.sql$ ]]; then
            echo "‚ùå Migration file $file doesn't follow naming convention V{version}__{description}.sql"
            exit 1
          fi
        done
        echo "‚úÖ All migration files follow naming convention"
    
    - name: Check for migration gaps
      run: |
        # Ensure migration versions are sequential with no gaps
        versions=($(ls src/db/migrations/V*.sql | sed 's/.*V\([0-9]\+\)__.*/\1/' | sort -n))
        for i in "${!versions[@]}"; do
          expected=$((i + 1))
          if [[ ${versions[i]} -ne $expected ]]; then
            echo "‚ùå Migration version gap detected. Expected V$expected, found V${versions[i]}"
            exit 1
          fi
        done
        echo "‚úÖ Migration versions are sequential"
    
    - name: Validate migration syntax
      run: |
        export DATABASE_URL=postgresql://${{ env.POSTGRES_USER }}:${{ env.POSTGRES_PASSWORD }}@localhost:5432/${{ env.POSTGRES_DB }}
        python scripts/migrate.py --dry-run --verbose
    
    - name: Run migrations
      run: |
        export DATABASE_URL=postgresql://${{ env.POSTGRES_USER }}:${{ env.POSTGRES_PASSWORD }}@localhost:5432/${{ env.POSTGRES_DB }}
        python scripts/migrate.py --verbose
    
    - name: Validate migration integrity
      run: |
        export DATABASE_URL=postgresql://${{ env.POSTGRES_USER }}:${{ env.POSTGRES_PASSWORD }}@localhost:5432/${{ env.POSTGRES_DB }}
        python scripts/migrate.py --validate
    
    - name: Test rollback preparation
      run: |
        # Test that we can at least connect and query migration status
        export DATABASE_URL=postgresql://${{ env.POSTGRES_USER }}:${{ env.POSTGRES_PASSWORD }}@localhost:5432/${{ env.POSTGRES_DB }}
        python scripts/migrate.py --status

  test-migration-docker:
    runs-on: ubuntu-latest
    needs: validate-migrations
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Build migration Docker image
      run: |
        docker build -f docker/Dockerfile.migrations -t migration-test .
    
    - name: Test migrations in Docker environment
      run: |
        # Start PostgreSQL
        docker run -d --name test-postgres \
          -e POSTGRES_DB=${{ env.POSTGRES_DB }} \
          -e POSTGRES_USER=${{ env.POSTGRES_USER }} \
          -e POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }} \
          -p 5432:5432 \
          postgres:15-alpine
        
        # Wait for PostgreSQL to be ready
        sleep 10
        
        # Run migrations in Docker
        docker run --rm \
          --network host \
          -e POSTGRES_HOST=localhost \
          -e POSTGRES_PORT=5432 \
          -e POSTGRES_DB=${{ env.POSTGRES_DB }} \
          -e POSTGRES_USER=${{ env.POSTGRES_USER }} \
          -e POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }} \
          -e DATABASE_URL=postgresql://${{ env.POSTGRES_USER }}:${{ env.POSTGRES_PASSWORD }}@localhost:5432/${{ env.POSTGRES_DB }} \
          migration-test
        
        # Clean up
        docker stop test-postgres
        docker rm test-postgres

  deploy-staging:
    runs-on: ubuntu-latest
    needs: [validate-migrations, test-migration-docker]
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Deploy to staging
      run: |
        echo "üöÄ Deploying migrations to staging environment"
        # Add your staging deployment logic here
        # This could include:
        # - Building and pushing Docker images
        # - Running migrations against staging database
        # - Updating staging environment
    
  deploy-production:
    runs-on: ubuntu-latest
    needs: [validate-migrations, test-migration-docker]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Deploy to production
      run: |
        echo "üöÄ Deploying migrations to production environment"
        # Add your production deployment logic here
        # This should include:
        # - Database backup before migration
        # - Running migrations with rollback plan
        # - Health checks after migration
        # - Notification on success/failure